package gui

import (
	"fmt"
	"go/format"
	"io"
	"reflect"
	"sort"
	"strings"

	"github.com/fyne-io/defyne/internal/guidefs"

	"fyne.io/fyne/v2"
)

// ExportGo generates a full Go package for the given object and writes it to the provided file handle
func ExportGo(obj fyne.CanvasObject, d DefyneContext, name string, w io.Writer) error {
	guidefs.InitOnce()

	packagesList := packagesRequired(obj, d)

	// Really this needs to be a full dependency analysis but for now a simple sort of widgets before containers may work
	varListWidgets, varListContainers := varsRequired(obj, d)
	sort.Strings(varListWidgets)
	sort.Strings(varListContainers)

	code := exportCode(packagesList, append(varListWidgets, varListContainers...), obj, d, name)

	_, err := w.Write([]byte(code))
	return err
}

// ExportGoPreview generates a preview version of the Go code with a `main()` method for the given object and writes it to the file handle
func ExportGoPreview(obj fyne.CanvasObject, d DefyneContext, w io.Writer) error {
	guidefs.InitOnce()

	packagesList := packagesRequired(obj, d)
	packagesList = append(packagesList, "app")

	// Really this needs to be a full dependency analysis but for now a simple sort of widgets before containers may work
	varListWidgets, varListContainers := varsRequired(obj, d)
	sort.Strings(varListWidgets)
	sort.Strings(varListContainers)

	code := exportCode(packagesList, append(varListWidgets, varListContainers...), obj, d, "main")

	code += `
func main() {
	myApp := app.New()
	myWindow := myApp.NewWindow("Hello")
	gui := newGUI()
	myWindow.SetContent(gui.makeUI())
	myWindow.ShowAndRun()
}
`
	_, err := w.Write([]byte(code))

	return err
}

func exportCode(pkgs, vars []string, obj fyne.CanvasObject, d DefyneContext, name string) string {
	for i := 0; i < len(pkgs); i++ {
		if pkgs[i] != "fmt" && pkgs[i] != "net/url" && pkgs[i] != "image/color" {
			pkgs[i] = "fyne.io/fyne/v2/" + pkgs[i]
		}

		pkgs[i] = fmt.Sprintf(`	"%s"`, pkgs[i])
	}

	defs := make(map[string]string)

	_, clazz := getTypeOf(obj)
	main := guidefs.GoString(clazz, obj, d, defs)
	setup := ""
	for k, v := range defs {
		setup += "g." + k + " = " + v + "\n"
	}

	guiName := "gui"
	guiNameUpper := ""
	if name != "main" {
		guiName = name + "Gui"
		guiNameUpper = strings.ToUpper(string([]byte{name[0]})) + name[1:]
	}
	code := fmt.Sprintf(`// auto-generated
// Code generated by GUI builder.

package main

import (
	"fyne.io/fyne/v2"
%s
)

type %s struct {
%s
}

func new%sGUI() *%s {
	return &%s{}
}

func (g *%s) makeUI() fyne.CanvasObject {
	%s

	return %s}
`,
		strings.Join(pkgs, "\n"),
		guiName,
		strings.Join(vars, "\n"),
		guiNameUpper, guiName, guiName, guiName,
		setup, main)

	formatted, err := format.Source([]byte(code))
	if err != nil {
		fyne.LogError("Failed to format GUI code", err)
		return code
	}
	return string(formatted)
}

func packagesRequired(obj fyne.CanvasObject, d DefyneContext) []string {
	ret := []string{"container"}
	var objs []fyne.CanvasObject
	if c, ok := obj.(*fyne.Container); ok {
		objs = c.Objects
		layout, ok := d.Metadata()[c]["layout"]
		if ok && (layout == "Form" || layout == "CustomPadded") {
			ret = append(ret, "layout")
		}
	} else {
		class := reflect.TypeOf(obj).String()
		info := guidefs.Lookup(class)

		if info != nil && info.IsContainer() {
			ret = packagesRequiredForWidget(obj, d)
			objs = info.Children(obj)
		} else {
			return packagesRequiredForWidget(obj, d)
		}
	}

	for _, w := range objs {
		for _, p := range packagesRequired(w, d) {
			added := false
			for _, exists := range ret {
				if p == exists {
					added = true
					break
				}
			}
			if !added {
				ret = append(ret, p)
			}
		}
	}
	return ret
}

func packagesRequiredForWidget(w fyne.CanvasObject, d DefyneContext) []string {
	name := reflect.TypeOf(w).String()
	if pkgs := guidefs.Lookup(name).Packages; pkgs != nil {
		return pkgs(w, d)
	}

	if _, ok := w.(fyne.Widget); ok {
		return []string{"widget"}
	}

	return []string{}
}

func varsRequired(obj fyne.CanvasObject, d DefyneContext) (widgets, containers []string) {
	name := d.Metadata()[obj]["name"]

	if c, ok := obj.(*fyne.Container); ok {
		if name != "" {
			containers = append(containers, name+" *fyne.Container")
		}

		for _, w := range c.Objects {
			w2, c2 := varsRequired(w, d)
			if len(w2) > 0 {
				widgets = append(widgets, w2...)
			}
			if len(c2) > 0 {
				containers = append(containers, c2...)
			}
		}
	} else {
		class := reflect.TypeOf(obj).String()
		info := guidefs.Lookup(class)

		if info != nil && info.IsContainer() {
			for _, child := range info.Children(obj) {
				w2, c2 := varsRequired(child, d)

				if len(w2) > 0 {
					widgets = append(widgets, w2...)
				}
				if len(c2) > 0 {
					containers = append(containers, c2...)
				}
			}
		}

		if name != "" {
			_, class := getTypeOf(obj)
			widgets = append(widgets, name+" "+class)
		}
	}

	return
}
